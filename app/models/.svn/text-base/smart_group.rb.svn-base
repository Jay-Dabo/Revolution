class SmartGroup < ActiveRecord::Base
  has_many :smart_group_rules, :dependent => :destroy
  
  validates_presence_of :name, :message => "You give this smart group a name."
  #validates_associated :smart_group_rules
  validate :must_have_at_least_one_rule
  
  def must_have_at_least_one_rule
      errors.add_to_base("You must have at least one rule.") if self.smart_group_rules.length.zero?
  end
  
  def check_for_at_least_one_rule
    errors.add("blah") unless self.smart_group_rules.size > 0
  end
  
  def found_people
    #having = "HAVING (MAX(events.date) < '2007-12-31')"
    combined_cond = Caboose::EZ::Condition.new
    self.smart_group_rules.each do |s|
      combined_cond << s.sql_conditions
    end
    
    @people = Person.find(:all,
                :select => ['people.id, people.household_id, people.gender, people.household_position, people.first_name, people.last_name, people.birthdate,
                             tags.name, groups.name, people.attendance_status'],
                :joins => ['LEFT OUTER JOIN taggings ON (people.id = taggings.person_id)
                            LEFT OUTER JOIN tags ON (tags.id = taggings.tag_id)
                            LEFT OUTER JOIN enrollments ON (people.id = enrollments.person_id)
                            LEFT OUTER JOIN groups ON (groups.id = enrollments.group_id)
                            LEFT OUTER JOIN attendances ON attendances.person_id = people.id 
                            LEFT OUTER JOIN meetings ON meetings.id = attendances.meeting_id 
                            LEFT OUTER JOIN instances ON instances.id = meetings.instance_id 
                            LEFT OUTER JOIN events ON events.id = instances.event_id
                            LEFT OUTER JOIN attendance_trackers ON attendance_trackers.person_id = people.id'],
                :include => :household,
                :conditions => combined_cond.to_sql,
                :group => ['people.id'])
    
    #@people = @people.select {|p| p.tags.collect {|t| t.name}.include?(self.tags_criterion)} if ! self.exclusive_tags.empty?
    @people = @people.select {|p| self.exclusive_tags.all? {|item| p.tags.collect {|t| t.name}.include?(item)}} unless self.exclusive_tags.empty?
    @people
  end
  
  def found_households
      #having = "HAVING (MAX(events.date) < '2007-12-31')"
      combined_cond = Caboose::EZ::Condition.new
      self.smart_group_rules.each do |s|
        combined_cond << s.sql_conditions
      end

      @people = Person.find(:all,
                  :select => ['people.id, people.household_id, people.gender, people.household_position, people.first_name, people.last_name, people.birthdate,
                               tags.name, groups.name, people.attendance_status, households.id'],
                  :joins => ['LEFT OUTER JOIN taggings ON (people.id = taggings.person_id)
                              LEFT OUTER JOIN tags ON (tags.id = taggings.tag_id)
                              LEFT OUTER JOIN enrollments ON (people.id = enrollments.person_id)
                              LEFT OUTER JOIN groups ON (groups.id = enrollments.group_id)
                              LEFT OUTER JOIN attendances ON attendances.person_id = people.id 
                              LEFT OUTER JOIN meetings ON meetings.id = attendances.meeting_id 
                              LEFT OUTER JOIN instances ON instances.id = meetings.instance_id 
                              LEFT OUTER JOIN events ON events.id = instances.event_id
                              LEFT OUTER JOIN attendance_trackers ON attendance_trackers.person_id = people.id'],
                  :include => :household,
                  :conditions => combined_cond.to_sql,
                  :group => ['people.household_id'])
      @people = @people.select {|p| self.exclusive_tags.all? {|item| p.tags.collect {|t| t.name}.include?(item)}} unless self.exclusive_tags.empty?
      @people
    end
    
    def exclusive_tags
      @result = []
      self.smart_group_rules.each {|r| @result << r.exclusive_tags}
      @result.compact.flatten
    end
    
  
end


